# RAG Integration

This folder contains the controller that exposes the RAG (Retrieval-Augmented Generation) integration endpoint.

Purpose
- Render a prompt from a template using the incoming request data
- Call an AI provider client with the rendered prompt
- Return the AI-generated text with metadata (duration, request id, task type)

Where to find the code
- Controller: `RagIntegration.cs` (exposes `POST /api/v1/rag/query`)
- Service: `Backend/Application/Rag/RagService.cs` (orchestrates prompt rendering and AI calls)
- Template service: `IPromptTemplateService` / `FileBasedPromptTemplateService` (Template files live under `Templates/Prompts` in the web app content root)

Input (request)
- Endpoint: `POST /api/v1/rag/query`
- Content-Type: `application/json`
- JSON shape: `RagQueryRequest` (examples below). Important fields:
  - `query` (string): the user's question or instruction to the AI.
  - `taskType` (string): selects which prompt template file to use (filename without extension).
  - `context` (string, optional): additional context to include in the prompt.
  - `provider` (string, optional): the AI provider identifier (the factory maps this to a client).

Minimal example request

```json
{
  "query": "Summarize the following text for a 10-year-old.",
  "taskType": "summary",
  "context": "Text from a biology article",
  "provider": "mock"
}
```

Processing steps (pipeline)
1. Controller validates the incoming model (DataAnnotations / ModelState).
2. Request is mapped to a domain model (via `RagMapper.ToDomain`).
3. `RagService` calls `IPromptTemplateService.Render(taskType, modelData)` to produce the final prompt text.
4. `AIProviderFactory` selects an AI client based on `provider` value.
5. The AI client is called with the rendered prompt; the response text is returned.
6. The controller measures duration, logs metadata, and returns a `RagQueryResponse` with result + meta.

Output (successful response)
- HTTP status: `200 OK`
- JSON shape: `RagQueryResponse`
  - `result` (string): the AI-generated text
  - `meta` (object): metadata about the request
    - `durationMs` (long): elapsed time in milliseconds for processing the request
    - `taskType` (string): the task type used for rendering
    - `requestId` (string): short identifier used for tracing/logging

Example success response

```json
{
  "result": "Here's a simple summary: ...",
  "meta": {
    "durationMs": 178,
    "taskType": "summary",
    "requestId": "f3a2b1c4"
  }
}
```

Errors and status codes
- `400 Bad Request` — validation failed. The response includes model state details.
- `503` or `5xx` — provider or internal service error. Errors are converted to RFC7807 Problem Details using the configured `IProblemDetailsFactory`.

Developer notes / tips
- Templates: placed under `Templates/Prompts` with filenames like `summary.tpl`. Placeholders use `{{key}}` and support nested properties with dot notation.
- If no template exists or rendering fails, the `FileBasedPromptTemplateService` falls back to a default prompt.
- Consider making template rendering async and using `ReadAllTextAsync` if you frequently read templates from disk.
- Improve observability: include the `requestId` in logs and structured tracing. Log exceptions when template reading/rendering fails.
- For richer templating or escaping needs, consider adopting a library (Scriban or RazorLight) instead of a homegrown replacement.

Quick links
- `RagIntegration.cs` — controller and HTTP contract
- `RagService.cs` — orchestration logic
- `IPromptTemplateService` / `FileBasedPromptTemplateService` — template loading and rendering

If you'd like, I can:
- Add a sample `Templates/Prompts/summary.tpl` file and a small unit test that verifies rendering.
- Convert `FileBasedPromptTemplateService` to async and add exception logging.

---
(autogenerated by a helper to document the RAG integration pipeline)